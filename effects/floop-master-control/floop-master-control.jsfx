desc:Floop Master Control
// @version 1.1.0
// @author Floop-s
// @license GPL-3.0
// @changelog
//   Optimized MPC Layout, Smart Scaling, UI Cleanup
// @about
//   Integrated master monitoring and analysis tool for REAPER.
//
//   Includes:
//   - True Peak limiting and metering
//   - LUFS integrated and short-term metering
//   - Spectrum analysis
//   - Phase correlation view
//
//   Useful for metering and monitoring during mastering.
//   Keywords: LUFS, spectrum, phase, true peak, monitoring.
// @provides
//   [effect] floop-master-control.jsfx



slider1:monitor_mode=0<0,2,1{Normal,Mono,Side}>Monitor Mode
slider2:out_gain_db=0<-60,12,0.1>Monitor Gain (dB)
slider3:dim_active=0<0,1,1>Dim (-20dB)
slider4:lp120_active=0<0,1,1>LP 120Hz
slider5:tp_limit_mode=0<0,2,1{-1.0 dBTP,-0.3 dBTP,0.0 dBTP}>True Peak Threshold
slider6:lufs_s_limit_db=-14<-36,0,0.1>LUFS-S Target
slider7:spec_avg_mode=0<0,2,1{Fast,Slow,Infinite}>Spectrum AVG
slider8:spec_slope_db=4.5<0,6,0.1>Spectrum Slope (dB/oct)
slider9:spec_freeze=0<0,1,1>Spectrum Freeze
slider11:spec_smooth_mode=0<0,2,1{1/3 Oct,1/12 Oct,1/24 Oct}>Smoothing
slider12:spec_mode_ms=0<0,1,1{Stereo,Mid/Side}>Spectrum Mode
slider13:phase_view_mode=0<0,1,1{Bar,Multi}>Phase View

options:no_meter

@init
ext_noinit = 1.0;

UI_SLIDER_MASK = (1<<16)-1;
sliders_showing = slider_show(UI_SLIDER_MASK, 0) > 0;

c_bg_r = 0.1; c_bg_g = 0.1; c_bg_b = 0.12; 
c_grid = 0.3;
c_txt = 0.8;
c_acc = 0.2; c_acc_g = 0.8; c_acc_b = 0.4; 

fft_size = 4096; // Increased resolution for mastering
fft_overlap_factor = 4; // 75% overlap
fft_step_size = fft_size / fft_overlap_factor;
fft_bins = fft_size/2;
buf_offset = 0;
buf_l = 0;
buf_r = 1024; 

mem_ptr = 2048; 

fft_buf = mem_ptr; mem_ptr += fft_size * 2; 
fft_buf_s = mem_ptr; mem_ptr += fft_size * 2;
fft_buf_g = mem_ptr; mem_ptr += fft_size;
fft_buf_g_s = mem_ptr; mem_ptr += fft_size;
spec_buf = mem_ptr; mem_ptr += fft_bins;
spec_buf_s = mem_ptr; mem_ptr += fft_bins;
spec_peak = mem_ptr; mem_ptr += fft_bins;
spec_peak_s = mem_ptr; mem_ptr += fft_bins;
corr_spec_buf = mem_ptr; mem_ptr += fft_bins;
win_buf = mem_ptr; mem_ptr += fft_size;

// Ring Buffers for FFT
fft_ring_size = fft_size * 2; // Sufficient buffer size
fft_ring_buf_m = mem_ptr; mem_ptr += fft_ring_size;
fft_ring_buf_s = mem_ptr; mem_ptr += fft_ring_size;
fft_ring_wr = 0;
fft_ring_pos = 0; // Tracks current window start position

tp_h = mem_ptr; mem_ptr += 32;
tp_s1 = mem_ptr; mem_ptr += 32;
tp_s2 = mem_ptr; mem_ptr += 32;
tp_s3 = mem_ptr; mem_ptr += 32;
tp_hist_l = mem_ptr; mem_ptr += 32;
tp_hist_r = mem_ptr; mem_ptr += 32;

lufs_st_buf = mem_ptr; mem_ptr += 64;
lufs_history_buf = mem_ptr; mem_ptr += 360000; // History buffer for Integrated Gating (~10 hours)
lufs_hist_cnt = mem_ptr; mem_ptr += 1000; // Histogram counts (0.1 dB resolution)
lufs_hist_p = mem_ptr; mem_ptr += 1000;   // Histogram power sums

scope_buf = mem_ptr; 

fft_ready = 0; 
inv_log10 = 1/log(10);
inv_log2 = 1/log(2);
log_1000 = log(1000);
gate_abs_p = pow(10, (-70 + 0.691) * 0.1); // Absolute Gate Threshold Power (-70 LUFS)
denorm = 10^-24; 

win_sum = 0;
i = 0;
loop(fft_size,
  // Hann Window
  win_buf[i] = 0.5 * (1 - cos(2*$pi*i/(fft_size-1)));
  // Adjust for overlap gain compensation: 
  // For 75% overlap (factor 4), energy increases. 
  // Simple energy normalization happens in @gfx usually, but window sum helps there.
  win_sum += win_buf[i];
  i += 1;
);
i = 0;
loop(fft_bins,
  spec_buf[i] = 0;
  spec_buf_s[i] = 0;
  i += 1;
);
i = 0;
loop(fft_bins,
  spec_peak[i] = 0;
  spec_peak_s[i] = 0;
  corr_spec_buf[i] = 0;
  i += 1;
);

ui_scale = 1.0; // Initialize ui_scale for HiDPI support
ui_w = 0; ui_h = 0;
last_mouse_cap = 0;

corr_smooth = 0;
corr_srate = srate;
corr_win = max(64, floor(corr_srate * 0.05));
corr_acc_ll = 0;
corr_acc_rr = 0;
corr_acc_lr = 0;
corr_acc_n = 0;

// --- Reaper / ITU-R BS.1770-4 True Peak Sinc Interpolation ---
sinc_sz = 32;
tp_block_peak = 0;
tp_meter = 0;
tp_max_peak = 0;

// Function to generate sinc value
function sinc_gen_val(slice_pos, sz) local(windowpos, sincpos) (
  windowpos = (2.0 * $pi / sz) * slice_pos;
  sincpos = $pi * (slice_pos - sz * 0.5);
  (0.53836 - cos(windowpos)*0.46164) * (abs(sincpos) < 0.000001 ? 1 : sin(sincpos) / sincpos);
);

// Generate coefficients for 4x oversampling (offsets 0.25, 0.5, 0.75)
tp_i = 0;
loop(sinc_sz,
  tp_s1[tp_i] = sinc_gen_val(tp_i + 0.25, sinc_sz);
  tp_s2[tp_i] = sinc_gen_val(tp_i + 0.50, sinc_sz);
  tp_s3[tp_i] = sinc_gen_val(tp_i + 0.75, sinc_sz);
  tp_i += 1;
);

// Clear history
memset(tp_hist_l, 0, sinc_sz);
memset(tp_hist_r, 0, sinc_sz);

lp_srate = 0;
lp_x1_l = lp_x2_l = lp_y1_l = lp_y2_l = 0;
lp_x1_r = lp_x2_r = lp_y1_r = lp_y2_r = 0;

gonio_decay = 0.95;
gonio_img = 3;
gonio_img_w = 0;
gonio_img_h = 0;

scope_srate = srate;
scope_max_seconds = 10; 
scope_size = max(1, floor(scope_srate * scope_max_seconds));
scope_view_seconds = 5; 
scope_wr = 0;
scope_filled = 0;
scope_show_l = 1;
scope_show_r = 1;

ui_monitor_mode = monitor_mode;
ui_dim_active = dim_active;
ui_lp120_active = lp120_active;
ui_low_end_only = 0;
ui_mid_high_focus = 0;

lufs_srate = 0;
lufs_sum = 0;
lufs_n = 0;
lufs_st_size = 30;
lufs_st_block_len = 0;
lufs_st_acc = 0;
lufs_st_n = 0;
lufs_st_sum = 0;
lufs_st_idx = 0;
lufs_st_filled = 0;
lufs_s_db = -120;
lufs_history_count = 0;
lufs_abs_sum = 0;
lufs_abs_count = 0;
lufs_i_db = -120;
i = 0;
loop(lufs_st_size,
  lufs_st_buf[i] = 0;
  i += 1;
);

function Reset() (
  lufs_st_idx = 0;
  lufs_st_filled = 0;
  lufs_st_sum = 0;
  lufs_st_acc = 0;
  lufs_st_n = 0;
  lufs_abs_sum = 0;
  lufs_abs_count = 0;
  lufs_history_count = 0;
  
  // Clear histograms and buffers
  memset(lufs_hist_cnt, 0, 1000);
  memset(lufs_hist_p, 0, 1000);
  memset(lufs_history_buf, 0, 360000); 
  memset(lufs_st_buf, 0, lufs_st_size);
  
  // Reset LUFS filters
  k_hp_d1_l = 0; k_hp_d2_l = 0;
  k_hp_d1_r = 0; k_hp_d2_r = 0;
  k_sh_d1_l = 0; k_sh_d2_l = 0;
  k_sh_d1_r = 0; k_sh_d2_r = 0;
  
  // Reset True Peak history
  memset(tp_hist_l, 0, sinc_sz);
  memset(tp_hist_r, 0, sinc_sz);
  tp_block_peak = 0;
  tp_max_peak = 0;
);

k_hp_x1_l = k_hp_x2_l = k_hp_y1_l = k_hp_y2_l = 0;
k_hp_x1_r = k_hp_x2_r = k_hp_y1_r = k_hp_y2_r = 0;
k_sh_x1_l = k_sh_x2_l = k_sh_y1_l = k_sh_y2_l = 0;
k_sh_x1_r = k_sh_x2_r = k_sh_y1_r = k_sh_y2_r = 0;

@block
gain = 10 ^ (out_gain_db / 20);
ui_dim_active != dim_active ? ui_dim_active = dim_active;
ui_monitor_mode != monitor_mode ? ui_monitor_mode = monitor_mode;
ui_lp120_active != lp120_active ? ui_lp120_active = lp120_active;

// Reset on playback start/seek
play_state&1 ? (
  abs(play_position - last_play_pos) > 0.1 ? Reset();
  last_play_pos = play_position + samplesblock/srate;
) : (
  last_play_pos = -1;
);

tp_limit_db =
  tp_limit_mode == 0 ? -1 :
  tp_limit_mode == 1 ? -0.3 : 0;

spec_smooth_a = spec_avg_mode == 0 ? 0.75 : spec_avg_mode == 1 ? 0.92 : 0.0;
spec_smooth_b = 1 - spec_smooth_a;
spec_peak_decay = spec_avg_mode == 0 ? 0.985 : spec_avg_mode == 1 ? 0.995 : 1.0;
spec_tilt_db_per_oct = slider8;

oct_smooth = spec_smooth_mode == 0 ? pow(2, 1/6) : spec_smooth_mode == 1 ? pow(2, 1/24) : pow(2, 1/48);

ui_dim_active ? gain *= 0.1;

tp_rel = pow(0.99995, samplesblock);
tp_meter *= tp_rel;
tp_block_peak > tp_meter ? tp_meter = tp_block_peak;
tp_block_peak = 0;

lp_srate != srate ? (
  lp_srate = srate;
  lp_fc = 120;
  lp_w0 = 2*$pi*lp_fc/lp_srate;
  lp_cosw0 = cos(lp_w0);
  lp_sinw0 = sin(lp_w0);
  lp_q = 0.70710678;
  lp_alpha = lp_sinw0 / (2*lp_q);
  lp_b0 = (1 - lp_cosw0) * 0.5;
  lp_b1 = 1 - lp_cosw0;
  lp_b2 = (1 - lp_cosw0) * 0.5;
  
  hp_b0 = (1 + lp_cosw0) * 0.5;
  hp_b1 = -(1 + lp_cosw0);
  hp_b2 = (1 + lp_cosw0) * 0.5;
  
  lp_a0 = 1 + lp_alpha;
  lp_a1 = -2*lp_cosw0;
  lp_a2 = 1 - lp_alpha;

  inv_a0 = 1.0 / lp_a0;
  lp_b0 *= inv_a0; lp_b1 *= inv_a0; lp_b2 *= inv_a0;
  hp_b0 *= inv_a0; hp_b1 *= inv_a0; hp_b2 *= inv_a0;
  lp_a1 *= inv_a0; lp_a2 *= inv_a0;

  lp_x1_l = lp_x2_l = lp_y1_l = lp_y2_l = 0;
  lp_x1_r = lp_x2_r = lp_y1_r = lp_y2_r = 0;

  mh_lp_x1_l = mh_lp_x2_l = mh_lp_y1_l = mh_lp_y2_l = 0;
  mh_lp_x1_r = mh_lp_x2_r = mh_lp_y1_r = mh_lp_y2_r = 0;
);

lufs_srate != srate ? (
  lufs_srate = srate;

  // --- Reaper / ITU-R BS.1770-4 Standard Coefficients ---
  // High Shelf (Stage 1)
  // f0 = 1681.974450955533; Q = 0.7071752369554196; Gain = 4dB
  db = 3.999843853973347;
  f0 = 1681.974450955533;
  Q = 0.7071752369554196;
  K = tan($pi * f0 / lufs_srate);
  Vh = pow(10, db/20);
  Vb = pow(Vh, 0.4996667741545416);
  a0 = 1 + K/Q + K*K;
  
  // Direct Form II coefficients (normalized by a0)
  k_sh_a1 = 2 * (K*K - 1) / a0;
  k_sh_a2 = (1 - K/Q + K*K) / a0;
  k_sh_b0 = (Vh + Vb*K/Q + K*K) / a0;
  k_sh_b1 = 2 * (K*K - Vh) / a0;
  k_sh_b2 = (Vh - Vb*K/Q + K*K) / a0;

  // High Pass (Stage 2)
  // f0 = 38.13547087602444; Q = 0.5003270373238773
  f0 = 38.13547087602444;
  Q = 0.5003270373238773;
  K = tan($pi * f0 / lufs_srate);
  
  hp_denom = 1 + K/Q + K*K;
  k_hp_a1 = 2 * (K*K - 1) / hp_denom;
  k_hp_a2 = (1 - K/Q + K*K) / hp_denom;
  k_hp_b0 = 1;
  k_hp_b1 = -2;
  k_hp_b2 = 1;
  
  lufs_st_block_len = max(1, floor(lufs_srate * 0.1)); // 100ms blocks per ITU-R BS.1770-4
  lufs_st_acc = 0;
  lufs_st_n = 0;
  lufs_st_sum = 0;
  lufs_st_idx = 0;
  lufs_st_filled = 0;
  lufs_s_db = -120;
  lufs_history_count = 0;
  lufs_abs_sum = 0;
  lufs_abs_count = 0;
  lufs_i_db = -120;
  i = 0;
  loop(lufs_st_size,
    lufs_st_buf[i] = 0;
    i += 1;
  );
  
  // Clear histogram
  i = 0;
  loop(1000,
    lufs_hist_cnt[i] = 0;
    lufs_hist_p[i] = 0;
    i += 1;
  );
);

scope_srate != srate ? (
  scope_srate = srate;
  scope_size = max(1, floor(scope_srate * scope_max_seconds));
  scope_wr = 0;
  scope_filled = 0;
);

corr_srate != srate ? (
  corr_srate = srate;
  corr_win = max(64, floor(corr_srate * 0.05));
  corr_acc_ll = 0;
  corr_acc_rr = 0;
  corr_acc_lr = 0;
  corr_acc_n = 0;
);

@sample
l = spl0;
r = spl1;

// --- True Peak Sinc Interpolation (Reaper Style) ---
// Shift history buffers
tp_i = sinc_sz - 1;
loop(sinc_sz - 1,
    tp_hist_l[tp_i] = tp_hist_l[tp_i-1];
    tp_hist_r[tp_i] = tp_hist_r[tp_i-1];
    tp_i -= 1;
);
tp_hist_l[0] = l;
tp_hist_r[0] = r;

// Center sample (no interpolation)
tp_center_idx = 16;
tp_max_l = abs(tp_hist_l[tp_center_idx]);
tp_max_r = abs(tp_hist_r[tp_center_idx]);

// Phase 1 (0.25 offset)
tp_sum_l = 0; tp_sum_r = 0;
tp_i = 0;
loop(sinc_sz,
    tp_sum_l += tp_hist_l[tp_i] * tp_s1[tp_i];
    tp_sum_r += tp_hist_r[tp_i] * tp_s1[tp_i];
    tp_i += 1;
);
tp_max_l = max(tp_max_l, abs(tp_sum_l));
tp_max_r = max(tp_max_r, abs(tp_sum_r));

// Phase 2 (0.50 offset)
tp_sum_l = 0; tp_sum_r = 0;
tp_i = 0;
loop(sinc_sz,
    tp_sum_l += tp_hist_l[tp_i] * tp_s2[tp_i];
    tp_sum_r += tp_hist_r[tp_i] * tp_s2[tp_i];
    tp_i += 1;
);
tp_max_l = max(tp_max_l, abs(tp_sum_l));
tp_max_r = max(tp_max_r, abs(tp_sum_r));

// Phase 3 (0.75 offset)
tp_sum_l = 0; tp_sum_r = 0;
tp_i = 0;
loop(sinc_sz,
    tp_sum_l += tp_hist_l[tp_i] * tp_s3[tp_i];
    tp_sum_r += tp_hist_r[tp_i] * tp_s3[tp_i];
    tp_i += 1;
);
tp_max_l = max(tp_max_l, abs(tp_sum_l));
tp_max_r = max(tp_max_r, abs(tp_sum_r));

tp_block_peak = max(tp_block_peak, max(tp_max_l, tp_max_r));
tp_max_peak = max(tp_max_peak, tp_block_peak);

k_in = l;

// Stage 1: High Shelf (Direct Form II)
// w[n] = x[n] - a1*w[n-1] - a2*w[n-2]
k_sh_w0 = k_in - k_sh_a1*k_sh_x1_l - k_sh_a2*k_sh_x2_l + denorm;
// y[n] = b0*w[n] + b1*w[n-1] + b2*w[n-2]
k_y = k_sh_b0*k_sh_w0 + k_sh_b1*k_sh_x1_l + k_sh_b2*k_sh_x2_l;
k_sh_x2_l = k_sh_x1_l; k_sh_x1_l = k_sh_w0;
k_in = k_y;

// Stage 2: High Pass (Direct Form II)
k_hp_w0 = k_in - k_hp_a1*k_hp_x1_l - k_hp_a2*k_hp_x2_l + denorm;
k_y = k_hp_b0*k_hp_w0 + k_hp_b1*k_hp_x1_l + k_hp_b2*k_hp_x2_l;
k_hp_x2_l = k_hp_x1_l; k_hp_x1_l = k_hp_w0;
l_k = k_y;

k_in = r;

// Stage 1: High Shelf (Direct Form II)
k_sh_w0 = k_in - k_sh_a1*k_sh_x1_r - k_sh_a2*k_sh_x2_r + denorm;
k_y = k_sh_b0*k_sh_w0 + k_sh_b1*k_sh_x1_r + k_sh_b2*k_sh_x2_r;
k_sh_x2_r = k_sh_x1_r; k_sh_x1_r = k_sh_w0;
k_in = k_y;

// Stage 2: High Pass (Direct Form II)
k_hp_w0 = k_in - k_hp_a1*k_hp_x1_r - k_hp_a2*k_hp_x2_r + denorm;
k_y = k_hp_b0*k_hp_w0 + k_hp_b1*k_hp_x1_r + k_hp_b2*k_hp_x2_r;
k_hp_x2_r = k_hp_x1_r; k_hp_x1_r = k_hp_w0;
r_k = k_y;

lufs_ms = (l_k*l_k + r_k*r_k);
lufs_sum += lufs_ms;
lufs_n += 1;

lufs_st_acc += lufs_ms;
lufs_st_n += 1;
lufs_st_n >= lufs_st_block_len ? (
    lufs_st_block_ms = lufs_st_acc / max(1, lufs_st_n);
    lufs_st_prev = lufs_st_buf[lufs_st_idx];
    lufs_st_buf[lufs_st_idx] = lufs_st_block_ms;
    
    // Short-Term is 3-second sliding window
    // If buffer full (30 blocks), subtract oldest, add newest
    lufs_st_filled >= lufs_st_size ? (
      lufs_st_sum += lufs_st_block_ms - lufs_st_prev;
    ) : (
      lufs_st_sum += lufs_st_block_ms;
      lufs_st_filled += 1;
    );
    
    lufs_st_idx = (lufs_st_idx + 1) % lufs_st_size;
    lufs_st_acc = 0;
    lufs_st_n = 0;
    
    // Short-Term LUFS calculation
    lufs_st_e = lufs_st_filled > 0 ? (lufs_st_sum / lufs_st_filled) : 0;
    lufs_s_db = lufs_st_e > 0 ? (-0.691 + 10*log(lufs_st_e) * inv_log10) : -120;
    
    // --- ITU-R BS.1770-4 Integrated Gating (Standard Implementation) ---
    // Gating uses 400ms rectangular window (4 blocks)
    lufs_st_filled >= 4 ? (
      idx0 = (lufs_st_idx - 1 + lufs_st_size) % lufs_st_size;
      idx1 = (lufs_st_idx - 2 + lufs_st_size) % lufs_st_size;
      idx2 = (lufs_st_idx - 3 + lufs_st_size) % lufs_st_size;
      idx3 = (lufs_st_idx - 4 + lufs_st_size) % lufs_st_size;
      curr_400ms_p = (lufs_st_buf[idx0] + lufs_st_buf[idx1] + lufs_st_buf[idx2] + lufs_st_buf[idx3]) * 0.25;

      // Absolute threshold gating (-70 LUFS)
      curr_400ms_p > gate_abs_p ? (
        // Update history buffer (limit to ~10 hours to avoid overflow)
        lufs_history_count < 360000 ? (
          lufs_history_buf[lufs_history_count] = curr_400ms_p;
          lufs_history_count += 1;
        );

        // Update sums and histogram (Infinite)
        lufs_abs_sum += curr_400ms_p;
        lufs_abs_count += 1;
        
        h_db = -0.691 + 10 * log(curr_400ms_p) * inv_log10;
        h_idx = floor((h_db + 70) * 10); 
        h_idx = max(0, min(999, h_idx));
        lufs_hist_cnt[h_idx] += 1;
        lufs_hist_p[h_idx] += curr_400ms_p;
      );

      // Relative threshold gating (-10 LU below absolute gated average)
      lufs_abs_count > 0 ? (
        gate_rel_p = (lufs_abs_sum / lufs_abs_count) * 0.1; // 0.1 is -10dB in power ratio
        
        r_db = -0.691 + 10 * log(gate_rel_p) * inv_log10;
        r_idx = floor((r_db + 70) * 10);
        r_idx = max(0, min(999, r_idx));
        
        lufs_rel_sum = 0;
        lufs_rel_count = 0;
        
        // Sum from histogram bins above relative threshold
        hi = r_idx;
        loop(1000 - r_idx,
          lufs_rel_sum += lufs_hist_p[hi];
          lufs_rel_count += lufs_hist_cnt[hi];
          hi += 1;
        );
        lufs_i_db = lufs_rel_count > 0 ? (-0.691 + 10*log(lufs_rel_sum / lufs_rel_count) * inv_log10) : -120;
      ) : (
        lufs_i_db = -120;
      );
    );
  );

buf_l[buf_offset] = l;
buf_r[buf_offset] = r;
buf_offset = (buf_offset + 1) % 1024;

mid = (l + r) * 0.5;
side = (l - r) * 0.5;

scope_buf[scope_wr*2] = l;     
scope_buf[scope_wr*2+1] = r;   
scope_wr += 1;
scope_wr >= scope_size ? scope_wr = 0;
scope_filled < scope_size ? scope_filled += 1;


out_l = l;
out_r = r;
ui_monitor_mode == 1 ? ( m = (out_l + out_r) * 0.5; out_l = m; out_r = m; );
ui_monitor_mode == 2 ? ( out_l = side; out_r = side; );

ui_low_end_only ? (
  lp_x = out_l;
  lp_y = lp_b0*lp_x + lp_b1*lp_x1_l + lp_b2*lp_x2_l - lp_a1*lp_y1_l - lp_a2*lp_y2_l + denorm;
  lp_x2_l = lp_x1_l; lp_x1_l = lp_x; lp_y2_l = lp_y1_l; lp_y1_l = lp_y;
  out_l = lp_y;

  lp_x = out_r;
  lp_y = lp_b0*lp_x + lp_b1*lp_x1_r + lp_b2*lp_x2_r - lp_a1*lp_y1_r - lp_a2*lp_y2_r + denorm;
  lp_x2_r = lp_x1_r; lp_x1_r = lp_x; lp_y2_r = lp_y1_r; lp_y1_r = lp_y;
  out_r = lp_y;
) :
ui_mid_high_focus ? (
  mh_lp_x = out_l;
  mh_lp_y = hp_b0*mh_lp_x + hp_b1*mh_lp_x1_l + hp_b2*mh_lp_x2_l - lp_a1*mh_lp_y1_l - lp_a2*mh_lp_y2_l + denorm;
  mh_lp_x2_l = mh_lp_x1_l; mh_lp_x1_l = mh_lp_x; mh_lp_y2_l = mh_lp_y1_l; mh_lp_y1_l = mh_lp_y;
  out_l = mh_lp_y;

  mh_lp_x = out_r;
  mh_lp_y = hp_b0*mh_lp_x + hp_b1*mh_lp_x1_r + hp_b2*mh_lp_x2_r - lp_a1*mh_lp_y1_r - lp_a2*mh_lp_y2_r + denorm;
  mh_lp_x2_r = mh_lp_x1_r; mh_lp_x1_r = mh_lp_x; mh_lp_y2_r = mh_lp_y1_r; mh_lp_y1_r = mh_lp_y;
  out_r = mh_lp_y;
) :
ui_lp120_active ? (
  lp_x = out_l;
  lp_y = lp_b0*lp_x + lp_b1*lp_x1_l + lp_b2*lp_x2_l - lp_a1*lp_y1_l - lp_a2*lp_y2_l + denorm;
  lp_x2_l = lp_x1_l; lp_x1_l = lp_x; lp_y2_l = lp_y1_l; lp_y1_l = lp_y;
  out_l = lp_y;

  lp_x = out_r;
  lp_y = lp_b0*lp_x + lp_b1*lp_x1_r + lp_b2*lp_x2_r - lp_a1*lp_y1_r - lp_a2*lp_y2_r + denorm;
  lp_x2_r = lp_x1_r; lp_x1_r = lp_x; lp_y2_r = lp_y1_r; lp_y1_r = lp_y;
  out_r = lp_y;
 );

corr_l = out_l;
corr_r = out_r;
corr_acc_ll += corr_l * corr_l;
corr_acc_rr += corr_r * corr_r;
corr_acc_lr += corr_l * corr_r;
corr_acc_n += 1;

corr_acc_n >= corr_win ? (
  denom = sqrt(corr_acc_ll * corr_acc_rr) + 0.000000000001;
  c = corr_acc_lr / denom;
  c > 1 ? c = 1;
  c < -1 ? c = -1;
  corr_smooth = corr_smooth * 0.80 + c * 0.20;
  corr_acc_ll = 0;
  corr_acc_rr = 0;
  corr_acc_lr = 0;
  corr_acc_n = 0;
);

spl0 = out_l * gain;
spl1 = out_r * gain;

// FFT Ring Buffer & Analysis
fft_in_m = (spl0 + spl1) * 0.5;
fft_in_s = (spl0 - spl1) * 0.5;

fft_ring_buf_m[fft_ring_wr] = fft_in_m;
fft_ring_buf_s[fft_ring_wr] = fft_in_s;
fft_ring_wr = (fft_ring_wr + 1) % fft_ring_size;

fft_ring_pos += 1;
fft_ring_pos >= fft_step_size ? (
  fft_ring_pos = 0;
  
  // Prepare Window
  r_ptr = fft_ring_wr - fft_size;
  r_ptr < 0 ? r_ptr += fft_ring_size;
  
  si = 0;
  loop(fft_size,
    sw = win_buf[si];
    fft_buf[si * 2] = fft_ring_buf_m[r_ptr] * sw;
    fft_buf[si * 2 + 1] = 0;
    fft_buf_s[si * 2] = fft_ring_buf_s[r_ptr] * sw;
    fft_buf_s[si * 2 + 1] = 0;
    
    r_ptr = (r_ptr + 1) % fft_ring_size;
    si += 1;
  );
  
  // Perform FFT
  fft(fft_buf, fft_size);
  fft(fft_buf_s, fft_size);
  fft_permute(fft_buf, fft_size);
  fft_permute(fft_buf_s, fft_size);
  
  fft_buf[1] = 0;
  fft_buf_s[1] = 0;
  
  // Process Spectrum
  si = 0;
  loop(fft_bins,
    // Mid Magnitude
    s_re = fft_buf[si * 2];
    s_im = fft_buf[si * 2 + 1];
    s_mag = sqrt(s_re * s_re + s_im * s_im) * (2 / max(0.000000000001, win_sum));
    
    // Side Magnitude
    s_re_s = fft_buf_s[si * 2];
    s_im_s = fft_buf_s[si * 2 + 1];
    s_mag_s = sqrt(s_re_s * s_re_s + s_im_s * s_im_s) * (2 / max(0.000000000001, win_sum));
    
    // Correlometer (L/R derivation)
    s_l_re = s_re + s_re_s; s_l_im = s_im + s_im_s;
    s_r_re = s_re - s_re_s; s_r_im = s_im - s_im_s;
    
    s_nom = s_l_re*s_r_re + s_l_im*s_r_im;
    s_denom = sqrt(s_l_re*s_l_re + s_l_im*s_l_im) * sqrt(s_r_re*s_r_re + s_r_im*s_r_im) + 0.000000000001;
    s_corr_val = s_nom / s_denom;
    corr_spec_buf[si] = corr_spec_buf[si] * 0.90 + s_corr_val * 0.10;
    
    // Smoothing & Peak
    spec_freeze == 0 ? (
      spec_avg_mode == 2 ? (
        spec_buf[si] = max(spec_buf[si], s_mag);
        spec_buf_s[si] = max(spec_buf_s[si], s_mag_s);
      ) : (
        spec_buf[si] = spec_buf[si] * spec_smooth_a + s_mag * spec_smooth_b;
        spec_buf_s[si] = spec_buf_s[si] * spec_smooth_a + s_mag_s * spec_smooth_b;
      );
      
      s_pk = spec_peak[si] * spec_peak_decay;
      s_mag > s_pk ? s_pk = s_mag;
      spec_peak[si] = s_pk;
      
      s_pk_s = spec_peak_s[si] * spec_peak_decay;
      s_mag_s > s_pk_s ? s_pk_s = s_mag_s;
      spec_peak_s[si] = s_pk_s;
    );
    
    si += 1;
  );
);

@gfx 240 980
  draw_tooltip = 0;

// FFT Processing (Ring Buffer with 75% overlap)
// Ensures smoother updates and correct temporal smoothing regardless of framerate.


function SetColor(r, g, b, a) ( gfx_r=r; gfx_g=g; gfx_b=b; gfx_a=a; );
function DrawBox(x, y, w, h, fill) (
  fill ? ( gfx_x=x; gfx_y=y; gfx_rectto(x+w, y+h); ) : ( gfx_rect(x, y, w, h); );
);
function DrawTextCent(x, y, w, h, str) (
  gfx_measurestr(str, str_w, str_h);
  gfx_x = x + (w - str_w)/2;
  gfx_y = y + (h - str_h)/2;
  gfx_drawstr(str);
);

function Clamp(v, lo, hi) (
  v < lo ? lo : v > hi ? hi : v;
);

function DrawSpectrumGraph(buf, r, g, b, a, is_line, is_fill, is_peak) (
  SetColor(r, g, b, a);
  
  prev_set = 0;
  i = 0;
  loop(disp_bins,
    t = i / (disp_bins - 1);
    lf = lf_min + t * lf_den;
    f = exp(lf);
    f_lo = f / oct_smooth;
    f_hi = f * oct_smooth;
    k0 = floor(f_lo * fft_size / srate);
    k1 = ceil(f_hi * fft_size / srate);
    k0 < 0 ? k0 = 0;
    k1 > fft_bins - 1 ? k1 = fft_bins - 1;
    k1 < k0 ? k1 = k0;

    is_peak ? (
      val = 0;
      k = k0;
      loop(k1 - k0 + 1,
        v = buf[k];
        v != v ? v = 0;
        v > val ? val = v;
        k += 1;
      );
    ) : (
      p = 0;
      n = 0;
      k = k0;
      loop(k1 - k0 + 1,
        v = buf[k];
        v != v ? v = 0;
        p += v * v;
        n += 1;
        k += 1;
      );
      val = n > 0 ? sqrt(p / n) : 0;
    );
    
    db = 20 * log(val + 0.000000000001) * inv_log10;
    spec_slope_db != 0 ? (
      db += spec_slope_db * ((lf - log_1000) * inv_log2);
    );
    db = Clamp(db, db_min, db_max);
    
    y2 = plot_y + (1 - (db - db_min) / (db_max - db_min)) * plot_h;
    x = plot_x + t * plot_w;
    
    is_fill ? (
      x2 = i < disp_bins - 1 ? (plot_x + ((i + 1) / (disp_bins - 1)) * plot_w) : (plot_x + plot_w + 1);
      w = x2 - x;
      w < 1 ? w = 1;
      gfx_rect(x, y2, w, (plot_y + plot_h) - y2);
    );
    
    is_line ? (
      prev_set ? gfx_line(prev_x, prev_y, x, y2, 1) : prev_set = 1;
      prev_x = x;
      prev_y = y2;
    );
    
    i += 1;
  );
);

function Button(x, y, w, h, label, toggle_state) (
  // Set font size relative to button height or global norm
  b_font_sz = max(f_sz_norm, min(floor(h * 0.6), 24));
  b_font_sz = max(b_font_sz, 13); // Minimum font size
  gfx_setfont(1, "Arial", b_font_sz);

  hover = mouse_x >= x && mouse_x < x+w && mouse_y >= y && mouse_y < y+h;
  down = hover && (mouse_cap&1);
  result = hover && (mouse_cap&1) && !(last_mouse_cap&1);

  SetColor(0.06, 0.06, 0.07, 1);
  DrawBox(x, y, w, h, 1);

  toggle_state ? (
    down ? SetColor(0.14, 0.62, 0.32, 1) : hover ? SetColor(0.20, 0.84, 0.44, 1) : SetColor(0.17, 0.75, 0.40, 1);
  ) : (
    down ? SetColor(0.16, 0.16, 0.18, 1) : hover ? SetColor(0.24, 0.24, 0.26, 1) : SetColor(0.20, 0.20, 0.22, 1);
  );
  DrawBox(x+1, y+1, w-2, h-2, 1);

  toggle_state ? SetColor(0.98, 0.98, 0.98, 0.95) : SetColor(0.90, 0.90, 0.90, 0.85);
  DrawTextCent(x, y, w, h, label);

  result;
);

function UpdateLayout() (
  // Adaptive layout calculation for MPC (compact) and Extended modes.
  
  // 0. Safety Check
  ui_scale <= 0 ? ui_scale = 1.0;

  // 1. Calculate Width-based Scale
  scale_w = (gfx_w / 380) * ui_scale;
  
  // 2. Calculate Height-based Limit
  // Reference: Header + Gaps + Panels = ~540px at scale 1.0
  scale_h = (gfx_h / 520) * ui_scale; 
  
  // 3. Determine Final Scale
  scale = min(scale_w, scale_h);
  
  // 4. Clamping
  scale = min(max(scale, 0.45), 2.0); 
  
  // Compact Mode Trigger (< 300px)
  compact_mode = gfx_w < 300;

  // Threshold 0.55: Differentiates between 15" screens (scale < 0.55) and 4K/Larger screens (scale >= 0.55) in MPC mode.
  // Below 0.55: Activates ultra-compact layout (hidden scope, abbreviated labels).
  small_screen_mode = scale < 0.55;

  pad = max(4, floor(8 * scale));
  gap = max(4, floor(8 * scale));
  panel_gap = gap;
  panel_pad = pad;
  
  header_h = max(20, floor(26 * scale));
  panel_title_h = max(20, floor(22 * scale));
  
  btn_ui_w = max(18, floor(22 * scale));
  btn_ui_h = max(16, floor(20 * scale));
  
  meter_bar_h = max(10, floor(16 * scale));
 // Font definitions
  f_sz_small = max(11, floor(11 * scale));
  f_sz_norm = max(13, floor(13 * scale));
  f_sz_title = max(15, floor(16 * scale));
  
  // Font scaling logic
  compact_mode ? (
    // MPC Mode: Fixed scale thresholds
    scale >= 0.55 ? (
       // Large screen/4K: Boost fonts
       f_sz_meter = max(18, floor(20 * scale));
       f_sz_norm = max(15, floor(15 * scale)); 
       f_sz_small = max(13, floor(13 * scale)); 
    ) : (
       // Small screen: Minimal sizes
       f_sz_meter = max(10, floor(11 * (scale / 0.45)));
    );
  ) : (
    // Extended Mode: Proportional scaling
    f_sz_meter = max(12, floor(16 * scale)); 
  );
  
  toolbar_h = max(20, floor(24 * scale));

  // Panel Height Calculation
  // Elastic height logic
  min_panel_h = max(35, 54 * (scale / 0.64)); 

  // 1. Calculate Base Optimal Heights
  base_h_reg = max(min_panel_h, floor(58 * scale));
  base_h_tp = max(min_panel_h, floor(58 * scale));
  base_h_mon = max(min_panel_h, floor(84 * scale));
  base_h_spec = max(min_panel_h, floor(80 * scale)); 
  
  // 2. Calculate Total Vertical Space Required (excluding expandable areas)
  total_gaps = (gap * 6) + header_h + pad; 
  
  // Hide Oscilloscope on small screens (< 0.55)
  compact_mode && scale < 0.55 ? (
      total_base_h = base_h_tp + (base_h_reg * 3) + base_h_mon + base_h_spec + total_gaps;
  ) : (
      total_base_h = base_h_tp + (base_h_reg * 4) + base_h_mon + base_h_spec + total_gaps;
  );
  
  // 3. Vertical Stretch Logic
  avail_h = gfx_h;
  
  avail_h > total_base_h ? (
     // Calculate Expansion Factor
     extra_h = avail_h - total_base_h;
     
     // Distribute extra height among panels (weighted)
     w_total = 1.2 + (1.2 * 4) + 1.5 + 1.5; 
     
     unit_extra = extra_h / w_total;
     
     panel_h_tp = base_h_tp + floor(unit_extra * 1.2);
     panel_h_reg = base_h_reg + floor(unit_extra * 1.2);
     panel_h_mon = base_h_mon + floor(unit_extra * 1.5);
     panel_h_spec = base_h_spec + floor(unit_extra * 1.5);

     // Assign residual pixels to Monitor panel
     
     compact_mode && scale < 0.55 ? (
        used_h = panel_h_tp + (panel_h_reg * 3) + panel_h_mon + panel_h_spec + total_gaps;
     ) : (
        used_h = panel_h_tp + (panel_h_reg * 4) + panel_h_mon + panel_h_spec + total_gaps;
     );

     residue = avail_h - used_h;
     residue > 0 ? (
       panel_h_mon += residue;
     );
  ) : (
     // Tight fit
     panel_h_tp = base_h_tp;
     panel_h_reg = base_h_reg;
     panel_h_mon = base_h_mon;
     panel_h_spec = base_h_spec;
  );
);

function Panel(x, y, w, h, title) (
  SetColor(0.07, 0.07, 0.08, 1);
  DrawBox(x, y, w, h, 1);
  SetColor(0.149, 0.149, 0.173, 1);
  DrawBox(x, y, w, h, 0);
  SetColor(1, 1, 1, 0.70);
  gfx_setfont(1, "Arial", f_sz_norm);
  gfx_x = x + pad;
  gfx_y = y + floor(6 * scale);
  gfx_drawstr(title);
);

gfx_dest = -1;


SetColor(c_bg_r, c_bg_g, c_bg_b, 1);
DrawBox(0, 0, gfx_w, gfx_h, 1);

(gfx_w != last_w || gfx_h != last_h || ui_scale != last_ui_scale) ? (
  UpdateLayout();
  last_w = gfx_w;
  last_h = gfx_h;
  last_ui_scale = ui_scale;
  gfx_setfont(1, "Arial", f_sz_norm);
);

SetColor(0.18, 0.18, 0.20, 1);
DrawBox(0, 0, gfx_w, header_h, 1);
SetColor(1, 1, 1, 0.92);
gfx_setfont(1, "Arial", f_sz_title);
DrawTextCent(0, 0, gfx_w, header_h, "Floop Master Control");


btn_ui_x = gfx_w - pad - btn_ui_w;
btn_ui_y = floor((header_h - btn_ui_h) * 0.5);
Button(btn_ui_x, btn_ui_y, btn_ui_w, btn_ui_h, "C", sliders_showing) ? (
  sliders_showing = slider_show(UI_SLIDER_MASK, -1) > 0;
);

x0 = pad;
x1 = gfx_w - pad;
y = header_h + gap;

row_w = x1 - x0;
row_w < 1 ? row_w = 1;

mouse_click = (mouse_cap&1) && !(last_mouse_cap&1);
mouse_click_r = (mouse_cap&2) && !(last_mouse_cap&2);
mouse_ctrl = mouse_cap&16;

// Vertical layout heights handled in UpdateLayout.

// Button sizing for general panels
btn_inner_h = panel_h_reg - panel_title_h - floor(6 * scale);
ui_btn_h = floor((btn_inner_h - gap) * 0.5);

// Ensure button height accommodates font size
min_btn_h = f_sz_norm + 4;
ui_btn_h = max(ui_btn_h, min_btn_h);
ui_btn_h = min(ui_btn_h, max(floor(32 * scale), min_btn_h));

// Logic for dyn_font_sz
dyn_font_sz = f_sz_meter;
dyn_font_sz = min(dyn_font_sz, floor(panel_h_reg * 0.80)); 
dyn_font_sz = max(dyn_font_sz, 9);

gfx_setfont(1, "Arial", dyn_font_sz);

panel_h = panel_h_tp;

peak_min_db = -60;
peak_max_db = 6;
tp_db = 20*log(tp_meter + 0.0000000001) * inv_log10;
tp_db = Clamp(tp_db, peak_min_db, peak_max_db);
tp_limit = Clamp(tp_limit_db, peak_min_db, peak_max_db);
tp_overs = tp_db - tp_limit;
tp_overs < 0 ? tp_overs = 0;
lufs_min_db = -36;
lufs_max_db = 6;
lufs_valid = lufs_st_filled > 0;
lufs_read_db = lufs_valid ? lufs_s_db : lufs_min_db;
lufs_val_db = Clamp(lufs_read_db, lufs_min_db, lufs_max_db);
lufs_limit = Clamp(lufs_s_limit_db, lufs_min_db, lufs_max_db);
lufs_overs = lufs_read_db - lufs_limit;
lufs_overs < 0 ? lufs_overs = 0;


label_w = floor(96 * scale);
value_w = floor(78 * scale);
meter_pad_x = floor(10 * scale);
// meter_bar_h handled in UpdateLayout

title_tp = compact_mode ? "TP" : "TRUE PEAK";
Panel(x0, y, row_w, panel_h, title_tp);
row1_y = y + panel_title_h;
meter_x = x0 + meter_pad_x;
meter_w = row_w - meter_pad_x*2;
bar_x = meter_x;
bar_w = meter_w;
bar_w < 1 ? bar_w = 1;

// Layout Logic: Anchor BAR to TOP, TEXT to CENTER/BOTTOM.
avail_h_inner = panel_h - panel_title_h - pad;
bar_y = row1_y + floor(avail_h_inner * 0.25);

SetColor(0.10, 0.10, 0.10, 1);
DrawBox(bar_x, bar_y, bar_w, meter_bar_h, 1);

SetColor(1, 1, 1, 0.10);
tick_db = peak_min_db;
ticks_n = floor((peak_max_db - peak_min_db)/6) + 1;
i = 0;
loop(ticks_n,
  tx = bar_x + (tick_db - peak_min_db) / (peak_max_db - peak_min_db) * bar_w;
  gfx_line(tx, bar_y, tx, bar_y + meter_bar_h);
  (tick_db == peak_min_db || tick_db == -48 || tick_db == -36 || tick_db == -24 || tick_db == -12 || tick_db == -6 || tick_db == 0 || tick_db == peak_max_db) ? (
    SetColor(1, 1, 1, 0.55);
    gfx_setfont(1, "Arial", f_sz_small);
    sprintf(#tstr, "%+.0f", tick_db);
    gfx_measurestr(#tstr, __tw, __th);
    gfx_x = tx - __tw*0.5;
    gfx_y = bar_y - __th - 1;
    gfx_drawstr(#tstr);
    SetColor(1, 1, 1, 0.10);
  );
  tick_db += 6;
  i += 1;
);

tp_norm = (tp_db - peak_min_db) / (peak_max_db - peak_min_db);
tp_norm = Clamp(tp_norm, 0, 1);
tp_fill = tp_norm * bar_w;

tp_lim_norm = (tp_limit - peak_min_db) / (peak_max_db - peak_min_db);
tp_lim_norm = Clamp(tp_lim_norm, 0, 1);
tp_lim_x = bar_x + tp_lim_norm * bar_w;

tp_warn_norm = (tp_limit - 1.0 - peak_min_db) / (peak_max_db - peak_min_db);
tp_warn_norm = Clamp(tp_warn_norm, 0, 1);
tp_warn_w = tp_warn_norm * bar_w;
tp_crit_w = tp_lim_norm * bar_w;

SetColor(1, 1, 1, 0.25);
gfx_line(tp_lim_x, bar_y - 2, tp_lim_x, bar_y + meter_bar_h + 2);

w_g = min(tp_fill, tp_warn_w);
w_g > 0 ? (
  gfx_gradrect(bar_x, bar_y, w_g, meter_bar_h, 0.15, 0.65, 0.35, 1.0, 0, 0, 0, 0, 0.005, 0.015, 0.005, 0); 
);

w_y = min(tp_fill, tp_crit_w) - tp_warn_w;
w_y > 0 ? (
  gfx_gradrect(bar_x + tp_warn_w, bar_y, w_y, meter_bar_h, 0.75, 0.65, 0.10, 1.0, 0, 0, 0, 0, 0.015, 0.015, 0.005, 0);
);

w_r = tp_fill - tp_crit_w;
w_r > 0 ? (
  gfx_gradrect(bar_x + tp_crit_w, bar_y, w_r, meter_bar_h, 0.75, 0.10, 0.10, 1.0, 0, 0, 0, 0, 0.015, 0.005, 0.005, 0);
);

tp_db > tp_limit ? SetColor(1, 0.25, 0.25, 1) : SetColor(0.9, 0.9, 0.9, 1);

// Dynamic Text Positioning
// Anchor text below the bar, centered in the remaining space
tp_value_y = bar_y + meter_bar_h + floor((avail_h_inner - (bar_y - row1_y) - meter_bar_h - dyn_font_sz)*0.5);

// Fail-safe: If calculated Y pushes text off panel, clamp it
max_text_y = y + panel_h - dyn_font_sz - floor(4 * scale);
tp_value_y = min(tp_value_y, max_text_y);

tp_font = dyn_font_sz;
gfx_setfont(1, "Arial", tp_font);
sprintf(#pstr, "%+.1f dB", tp_db);
gfx_measurestr(#pstr, tp_tw, tp_th);
tp_tw > meter_w - floor(4 * scale) ? (
  sprintf(#pstr, "%+.1f", tp_db);
  gfx_measurestr(#pstr, tp_tw, tp_th);
);

gfx_x = meter_x + meter_w - tp_tw;
gfx_x < meter_x ? gfx_x = meter_x;
gfx_y = tp_value_y;
gfx_drawstr(#pstr);

tp_max_db_val = 20*log(tp_max_peak + 0.0000000001) * inv_log10;
tp_max_peak == 0 ? tp_max_db_val = -144.0; 

gfx_setfont(1, "Arial", dyn_font_sz);
sprintf(#max_lbl, "MAX:");
gfx_measurestr(#max_lbl, max_lbl_w, max_lbl_h);

tp_max_db_val <= -100 ? sprintf(#max_val_str, "-inf dB") : sprintf(#max_val_str, "%+.1f dB", tp_max_db_val);
gfx_measurestr(#max_val_str, max_val_w, max_val_h);

max_x = meter_x;
max_y = tp_value_y + (tp_th - max_val_h)/2; 

hover_max = mouse_x >= max_x && mouse_x <= max_x + max_lbl_w + floor(4 * scale) + max_val_w && mouse_y >= max_y && mouse_y <= max_y + max_val_h;

mouse_click && hover_max ? (
  tp_max_peak = 0;
  tp_max_db_val = -144.0;
);

hover_val = mouse_x >= meter_x && mouse_x <= meter_x + meter_w && mouse_y >= tp_value_y && mouse_y <= tp_value_y + tp_th;
mouse_click && hover_val ? (
  tp_max_peak = 0;
  tp_max_db_val = -144.0;
);

SetColor(1, 1, 1, hover_max ? 0.9 : 0.7);
gfx_x = max_x;
gfx_y = max_y; 
gfx_drawstr(#max_lbl);

tp_max_db_val > tp_limit ? SetColor(1, 0.25, 0.25, 1) : SetColor(1, 1, 1, hover_max ? 1.0 : 0.9);
gfx_x += floor(4 * scale);
gfx_drawstr(#max_val_str);

y += panel_h + gap;

panel_h = panel_h_reg;
title_lufs = compact_mode ? "LUFS" : "LUFS METER";
Panel(x0, y, row_w, panel_h, title_lufs);
row2_y = y + panel_title_h;
meter_x = x0 + meter_pad_x;
meter_w = row_w - meter_pad_x*2;
btn_h = panel_title_h - 4;
btn_w = min(floor(110 * scale), max(24, max(floor(44 * scale), floor(meter_w * 0.34))));
btn_x = x0 + row_w - floor(6 * scale) - btn_w;
btn_y = y + (panel_title_h - btn_h) / 2;

gfx_setfont(1, "Arial", f_sz_small);
// Use short label "RST" on small screens (< 0.55 scale)
(compact_mode && scale < 0.55) ? (
  sprintf(#lufs_btn, "RST");
) : (
  sprintf(#lufs_btn, "RESET");
  gfx_measurestr(#lufs_btn, __tw, __th);
  __tw > btn_w - floor(12 * scale) ? sprintf(#lufs_btn, "RST");
);

Button(btn_x, btn_y, btn_w, btn_h, #lufs_btn, 0) ? (
  lufs_sum = 0;
  lufs_n = 0;
  lufs_st_acc = 0;
  lufs_st_n = 0;
  lufs_st_sum = 0;
  lufs_st_idx = 0;
  lufs_st_filled = 0;
  lufs_s_db = -120;
  i = 0;
  loop(lufs_st_size,
    lufs_st_buf[i] = 0;
    i += 1;
  );
  lufs_history_count = 0;
  lufs_abs_sum = 0;
  lufs_abs_count = 0;
  lufs_i_db = -120;
  i = 0;
  loop(1000,
    lufs_hist_cnt[i] = 0;
    lufs_hist_p[i] = 0;
    i += 1;
  );
);

lufs_val_db >= lufs_limit - 1 && lufs_val_db < lufs_limit ? (lr=0.95; lg=0.80; lb=0.15;) : (lr=0.20; lg=0.85; lb=0.45;);

bar_x = meter_x;
bar_w = meter_w;
bar_w < 1 ? bar_w = 1;

SetColor(1, 1, 1, 0.45);
gfx_setfont(1, "Arial", f_sz_small);
sprintf(#limstr2, "LIM %+.1f", lufs_s_limit_db);
gfx_x = meter_x;
gfx_y = row2_y + floor(2 * scale);
gfx_drawstr(#limstr2);

// Dynamic layout
    vals_font = dyn_font_sz;
    gfx_setfont(1, "Arial", f_sz_small); // Measure LIM height
    gfx_measurestr("LIM", __tw, lim_h);
    
    gfx_setfont(1, "Arial", vals_font); // Restore vals font
    gfx_measurestr("ST -inf LUFS", __tw, vals_h);

    // Constraints
    min_top_y = row2_y + floor(2 * scale) + lim_h + floor(2 * scale); 
    min_bot_pad = floor(4 * scale); 
    gap_text_bar = floor(4 * scale);

    // Ideal Layout
    bar_y = y + panel_h - meter_bar_h - floor(8 * scale);
    vals_y = bar_y - vals_h - gap_text_bar;

    // Collision Resolution
    vals_y < min_top_y ? (
      vals_y = min_top_y;
      bar_y = vals_y + vals_h + gap_text_bar;
      
      // Clamp Bar Height if needed
      max_bar_y = y + panel_h - min_bot_pad;
      (bar_y + meter_bar_h > max_bar_y) ? (
        avail_h = max_bar_y - bar_y;
        meter_bar_h = max(4, avail_h); 
      );
    );

lufs_valid ? (
  lufs_s_db < -99 ? sprintf(#lufs_st_str, "ST -inf") : sprintf(#lufs_st_str, "ST %+.1f", lufs_s_db);
) : (
  sprintf(#lufs_st_str, "ST --.-");
);

lufs_abs_count > 0 ? (
  lufs_i_db < -99 ? sprintf(#lufs_i_str, "INT -inf") : sprintf(#lufs_i_str, "INT %+.1f", lufs_i_db);
) : (
  sprintf(#lufs_i_str, "INT --.-");
);

lufs_overs > 0.01 ? SetColor(1, 0.25, 0.25, 0.95) : SetColor(lr, lg, lb, 0.95);
gfx_x = meter_x;
gfx_y = vals_y;
gfx_drawstr(#lufs_st_str);

SetColor(1, 1, 1, 0.85);
gfx_measurestr(#lufs_i_str, __tw, __th);
gfx_x = meter_x + meter_w - __tw;
gfx_x < meter_x ? gfx_x = meter_x;
gfx_y = vals_y;
gfx_drawstr(#lufs_i_str);

SetColor(0.10, 0.10, 0.10, 1);
DrawBox(bar_x, bar_y, bar_w, meter_bar_h, 1);

SetColor(1, 1, 1, 0.10);
tick_db = lufs_min_db;
ticks_n = floor((lufs_max_db - lufs_min_db)/6) + 1;
i = 0;
loop(ticks_n,
  tx = bar_x + (tick_db - lufs_min_db) / (lufs_max_db - lufs_min_db) * bar_w;
  gfx_line(tx, bar_y, tx, bar_y + meter_bar_h);
  (tick_db == lufs_min_db || tick_db == -24 || tick_db == -18 || tick_db == -12 || tick_db == -6 || tick_db == lufs_max_db) ? (
    SetColor(1, 1, 1, 0.55);
    gfx_setfont(1, "Arial", f_sz_small);
    sprintf(#tstr, "%+.0f", tick_db);
    gfx_measurestr(#tstr, __tw, __th);
    gfx_x = tx - __tw*0.5;
    bar_y > vals_y + vals_h + __th + floor(6 * scale) ? (
      gfx_y = bar_y - __th - 1;
      gfx_drawstr(#tstr);
    );
    SetColor(1, 1, 1, 0.10);
  );
  tick_db += 6;
  i += 1;
);

lufs_norm = (lufs_val_db - lufs_min_db) / (lufs_max_db - lufs_min_db);
lufs_norm = Clamp(lufs_norm, 0, 1);
lufs_fill = lufs_valid ? (lufs_norm * bar_w) : 0;

lufs_lim_norm = (lufs_limit - lufs_min_db) / (lufs_max_db - lufs_min_db);
lufs_lim_norm = Clamp(lufs_lim_norm, 0, 1);
lufs_lim_x = bar_x + lufs_lim_norm * bar_w;

lufs_warn_norm = (lufs_limit - 1.0 - lufs_min_db) / (lufs_max_db - lufs_min_db);
lufs_warn_norm = Clamp(lufs_warn_norm, 0, 1);
lufs_warn_w = lufs_warn_norm * bar_w;
lufs_crit_w = lufs_lim_norm * bar_w;

SetColor(1, 1, 1, 0.25);
gfx_line(lufs_lim_x, bar_y - 2, lufs_lim_x, bar_y + meter_bar_h + 2);

lufs_valid ? (
  w_g = min(lufs_fill, lufs_warn_w);
  w_g > 0 ? (
    gfx_gradrect(bar_x, bar_y, w_g, meter_bar_h, 0.15, 0.65, 0.35, 1.0, 0, 0, 0, 0, 0.005, 0.015, 0.005, 0); 
  );

  w_y = min(lufs_fill, lufs_crit_w) - lufs_warn_w;
  w_y > 0 ? (
    gfx_gradrect(bar_x + lufs_warn_w, bar_y, w_y, meter_bar_h, 0.75, 0.65, 0.10, 1.0, 0, 0, 0, 0, 0.015, 0.015, 0.005, 0);
  );

  w_r = lufs_fill - lufs_crit_w;
  w_r > 0 ? (
    gfx_gradrect(bar_x + lufs_crit_w, bar_y, w_r, meter_bar_h, 0.75, 0.10, 0.10, 1.0, 0, 0, 0, 0, 0.015, 0.005, 0.005, 0);
  );
);

y += panel_h + gap;

title_phase = compact_mode ? "PHASE" : "PHASE CORRELATION";
Panel(x0, y, row_w, panel_h, title_phase);

pc_view_btn_h = panel_title_h - 4;
pc_view_btn_w = floor(70 * scale);
pc_view_btn_x = x0 + row_w - floor(6 * scale) - pc_view_btn_w;
pc_view_btn_y = y + (panel_title_h - pc_view_btn_h) / 2;

mode_lbl = compact_mode ? (phase_view_mode == 0 ? "BAR" : "MUL") : (phase_view_mode == 0 ? "MODE: BAR" : "MODE: MULTI");
sprintf(#view_str, "%s", mode_lbl);

Button(pc_view_btn_x, pc_view_btn_y, pc_view_btn_w, pc_view_btn_h, #view_str, 0) ? (
  phase_view_mode = 1 - phase_view_mode;
  slider13 = phase_view_mode;
  slider_automate(slider13);
);

pc_pad = pad;
pc_x = x0 + pc_pad;
pc_w = row_w - pc_pad*2;
pc_w < 1 ? pc_w = 1;

pc_btn_h = btn_ui_h;
pc_btn_y = y + panel_h - pc_btn_h - pad;
pc_btn_w = (pc_w - gap) * 0.5;
pc_btn_w < floor(10 * scale) ? pc_btn_w = floor(10 * scale);
// Button height: 16px (small) or 24px (standard)
min_h = (scale < 0.55) ? 16 : 24;
pc_btn_h < min_h ? (
  pc_btn_h = min_h;
  pc_btn_y = y + panel_h - pc_btn_h - pad; // Re-adjust Y position
);
pc_btn_x_l = pc_x;
pc_btn_x_r = pc_x + pc_btn_w + gap;

phase_view_mode == 0 ? (
  // Centered bar layout
  gfx_setfont(1, "Arial", f_sz_small);
  gfx_measurestr("-1", tw_m1, th_m1);
  gfx_measurestr("+1", tw_p1, th_p1);
  label_margin = max(tw_m1, tw_p1) + floor(8 * scale);

  bar_w = pc_w - (label_margin * 2);
  bar_w < 10 ? bar_w = 10; // Minimum width
  
  bar_x = pc_x + (pc_w - bar_w) * 0.5;
  bar_h = floor(14 * scale);
  
  // Center the bar vertically between Title and Bottom Buttons
  avail_top = y + panel_title_h;
  avail_bot = pc_btn_y; 
  bar_y = avail_top + (avail_bot - avail_top - bar_h) * 0.5;

  gfx_gradrect(bar_x, bar_y, bar_w, bar_h, 1, 0, 0, 0.2, -1/bar_w, 1/bar_w, 0, 0);
  SetColor(1, 1, 1, 0.10);
  gfx_line(bar_x + bar_w*0.5, bar_y, bar_x + bar_w*0.5, bar_y + bar_h);
  gfx_line(bar_x, bar_y + bar_h*0.5, bar_x + bar_w, bar_y + bar_h*0.5);

  SetColor(1, 1, 1, 0.08);
  ti = 0;
  loop(9,
    tx = bar_x + (ti/8) * bar_w;
    gfx_line(tx, bar_y, tx, bar_y + bar_h);
    ti += 1;
  );

  SetColor(1, 1, 1, 0.55);
  // Labels aae noels frnow safe
  gfx_x = bar_x - tw_m1 - floor(4 * scale);
  gfx_y = bar_y + (bar_h - th_m1) * 0.5;
  gfx_drawstr("-1");
  gfx_x = bar_x + bar_w + floor(4 * scale);
  gfx_y = bar_y + (bar_h - th_p1) * 0.5;
  gfx_drawstr("+1");

  c_val = corr_smooth;
  c_val > 1 ? c_val = 1;
  c_val < -1 ? c_val = -1;
  c_val > 0.5 ? (cr = 0.20; cg = 0.85; cb = 0.40;) :
  c_val > 0.2 ? (cr = 0.90; cg = 0.80; cb = 0.20;) :
  c_val < 0 ? (cr = 0.90; cg = 0.20; cb = 0.20;) :
               (cr = 0.90; cg = 0.50; cb = 0.20;);
  SetColor(cr, cg, cb, 1);
  marker_x = bar_x + (bar_w*0.5) + (c_val * (bar_w*0.5));
  DrawBox(marker_x - floor(3 * scale), bar_y - floor(2 * scale), floor(6 * scale), bar_h + floor(4 * scale), 1);

  sprintf(#corr_val, "%+.2f", corr_smooth);
  
  // Use larger font for value
  gfx_setfont(1, "Arial", dyn_font_sz); 
  
  gfx_measurestr(#corr_val, cw, ch);
  gfx_x = bar_x + bar_w - cw; gfx_y = bar_y - ch - floor(2 * scale);
  SetColor(1,1,1,0.6); gfx_drawstr(#corr_val);
) : (
  mb_x = pc_x;
  mb_w = pc_w;
  mb_y = y + panel_title_h + floor(4 * scale);
  mb_h = pc_btn_y - mb_y - floor(4 * scale); 
  mb_w < 1 ? mb_w = 1;
  mb_h < 1 ? mb_h = 1;

  SetColor(0.0, 0.0, 0.0, 0.3);
  gfx_rect(mb_x, mb_y, mb_w, mb_h);
  
  cy = mb_y + mb_h * 0.5;

  SetColor(1, 1, 1, 0.2);
  gfx_line(mb_x, cy, mb_x + mb_w, cy);

  f_min = 20; f_max = srate * 0.5;
  lf_min = log(f_min); lf_max = log(f_max); lf_den = lf_max - lf_min;
  
  SetColor(1, 1, 1, 0.1);
  f = 100;
  while(f < f_max) (
    fx = mb_x + (log(f) - lf_min) / lf_den * mb_w;
    gfx_line(fx, mb_y, fx, mb_y + mb_h);
    f *= 10;
  );

  corr_disp_bins = floor(mb_w);
  corr_disp_bins > 600 ? corr_disp_bins = 600;
  corr_disp_bins < 100 ? corr_disp_bins = 100;
  
  i = 0;
  loop(corr_disp_bins,
    t = i / (corr_disp_bins - 1);
    lf = lf_min + t * lf_den;
    f = exp(lf);
    
    f_lo = f / oct_smooth;
    f_hi = f * oct_smooth;
    k0 = floor(f_lo * fft_size / srate);
    k1 = ceil(f_hi * fft_size / srate);
    k0 < 0 ? k0 = 0; k1 > fft_bins - 1 ? k1 = fft_bins - 1; k1 < k0 ? k1 = k0;
    
    c_sum = 0; c_n = 0;
    k = k0;
    loop(k1 - k0 + 1,
       c_sum += corr_spec_buf[k];
       c_n += 1;
       k += 1;
    );
    c_val = c_n > 0 ? c_sum / c_n : 0;
    c_val = Clamp(c_val, -1, 1);
    
    x = mb_x + t * mb_w;
    w = (mb_x + ((i+1)/(corr_disp_bins-1))*mb_w) - x;
    w < 1 ? w = 1;
    
    y_target = cy - c_val * (mb_h * 0.5);
    
    c_val >= 0 ? SetColor(0.2, 0.85, 0.4, 0.8) : SetColor(0.9, 0.3, 0.3, 0.8);
    
    y_target < cy ? (
       gfx_rect(x, y_target, w, cy - y_target);
    ) : (
       gfx_rect(x, cy, w, y_target - cy);
    );
    
    i += 1;
  );
);

// Shorten labels on small screens
lbl_mid = (compact_mode && scale < 0.55) ? "MID" : "SOLO MID";
lbl_side = (compact_mode && scale < 0.55) ? "SIDE" : "SOLO SIDE";

Button(pc_btn_x_l, pc_btn_y, pc_btn_w, pc_btn_h, lbl_mid, ui_monitor_mode == 1) ? (
  ui_monitor_mode == 1 ? (ui_monitor_mode = 0; slider1 = 0; monitor_mode = 0;) : (ui_monitor_mode = 1; slider1 = 1; monitor_mode = 1;);
  slider_automate(slider1);
);
Button(pc_btn_x_r, pc_btn_y, pc_btn_w, pc_btn_h, lbl_side, ui_monitor_mode == 2) ? (
  ui_monitor_mode == 2 ? (ui_monitor_mode = 0; slider1 = 0; monitor_mode = 0;) : (ui_monitor_mode = 2; slider1 = 2; monitor_mode = 2;);
  slider_automate(slider1);
);

y += panel_h + panel_gap;

// Hide Oscilloscope if scale < 0.55
(scale >= 0.55) ? (
  title_scope = compact_mode ? "SCOPE" : "OSCILLOSCOPE";
Panel(x0, y, row_w, panel_h, title_scope);

btn_w = max(24, floor(24 * scale)); // Minimum width 24px
btn_h = panel_title_h - 4;
btn_y = y + (panel_title_h - btn_h) / 2;
btn_x_r = x0 + row_w - panel_pad - btn_w;
btn_x_l = btn_x_r - btn_w - floor(4 * scale);

Button(btn_x_l, btn_y, btn_w, btn_h, "L", scope_show_l) ? (
  scope_show_l = 1 - scope_show_l;
);
Button(btn_x_r, btn_y, btn_w, btn_h, "R", scope_show_r) ? (
  scope_show_r = 1 - scope_show_r;
);

plot_x = x0 + panel_pad;
plot_y = y + panel_title_h + floor(2 * scale);
plot_w = row_w - panel_pad*2;
plot_h = panel_h - panel_title_h - floor(26 * scale);
plot_w < 1 ? plot_w = 1;
plot_h < 1 ? plot_h = 1;
mid_y0 = plot_y + plot_h/2;
plot_scale = (plot_h * 0.5);

mouse_x >= plot_x && mouse_x < plot_x + plot_w && mouse_y >= plot_y && mouse_y < plot_y + plot_h ? (
  mouse_wheel != 0 ? (
    scope_view_seconds *= (mouse_wheel > 0 ? 0.9 : 1.1); // Zoom in/out
    scope_view_seconds = Clamp(scope_view_seconds, 0.1, scope_max_seconds);
    mouse_wheel = 0;
  );
);

SetColor(1, 1, 1, 0.09);
sec = 0;
loop(ceil(scope_view_seconds) + 1,
  tx = plot_x + (sec / scope_view_seconds) * plot_w;
  tx <= plot_x + plot_w ? gfx_line(tx, plot_y, tx, plot_y + plot_h);
  sec += 1;
);

SetColor(1, 1, 1, 0.08);
gfx_line(plot_x, mid_y0, plot_x + plot_w, mid_y0);
gfx_line(plot_x, mid_y0 - plot_scale, plot_x + plot_w, mid_y0 - plot_scale);
gfx_line(plot_x, mid_y0 + plot_scale, plot_x + plot_w, mid_y0 + plot_scale);
gfx_line(plot_x, mid_y0 - plot_scale*0.5, plot_x + plot_w, mid_y0 - plot_scale*0.5);
gfx_line(plot_x, mid_y0 + plot_scale*0.5, plot_x + plot_w, mid_y0 + plot_scale*0.5);

scope_n = max(0, scope_filled);
scope_n > 1 ? (
  scope_n = min(scope_n, floor(scope_view_seconds * scope_srate));
  
  scope_cols = min(800, floor(plot_w));
  scope_cols < 2 ? scope_cols = 2;
  scope_n < scope_cols ? scope_cols = scope_n;
  scope_cols < 2 ? scope_cols = 2;

  scope_filled < scope_size ? (
    scope_oldest = scope_filled - scope_n;
  ) : (
    scope_oldest = (scope_wr - scope_n + scope_size) % scope_size;
  );
  
  scope_win = scope_n / scope_cols;
  scope_win < 1 ? scope_win = 1;

  ch = 0;
  loop(2,
    should_draw = (ch == 0 && scope_show_l) || (ch == 1 && scope_show_r);
    should_draw ? (
      col = 0;
      loop(scope_cols,
        s0 = floor(col * scope_win);
        s0 > scope_n - 1 ? s0 = scope_n - 1;
        s1 = floor((col + 1) * scope_win);
        s1 > scope_n ? s1 = scope_n;
        s1 <= s0 ? s1 = s0 + 1;
        s1 > scope_n ? s1 = scope_n;

        s = s0;
        idx = scope_oldest + s;
        idx >= scope_size ? idx -= scope_size;
        v = scope_buf[idx*2 + ch]; 
        v != v ? v = 0;
        v > 2 ? v = 2;
        v < -2 ? v = -2;
        mn = v; mx = v;

        s += 1;
        loop(max(0, s1 - s),
          idx = scope_oldest + s;
          idx >= scope_size ? idx -= scope_size;
          v = scope_buf[idx*2 + ch]; 
          v != v ? v = 0;
          v > 2 ? v = 2;
          v < -2 ? v = -2;
          v < mn ? mn = v;
          v > mx ? mx = v;
          s += 1;
        );

        (mx > 1.0 || mn < -1.0) ? SetColor(1.0, 0.2, 0.2, 0.9) : 
        ch == 0 ? SetColor(0.9, 0.9, 0.9, 0.7) : SetColor(0.2, 0.9, 0.2, 0.7);

        x = plot_x + (col / (scope_cols - 1)) * plot_w;
        y1 = mid_y0 - mx * plot_scale;
        y2 = mid_y0 - mn * plot_scale;
        y1 = Clamp(y1, plot_y, plot_y + plot_h);
        y2 = Clamp(y2, plot_y, plot_y + plot_h);
        gfx_line(x, y1, x, y2);
        col += 1;
      );
    );
    ch += 1;
  );
);

SetColor(1, 1, 1, 0.55);
gfx_setfont(1, "Arial", f_sz_small);
sec = 0;
loop(ceil(scope_view_seconds) + 1,
  tx = plot_x + (sec / scope_view_seconds) * plot_w;
  sprintf(#tsec, "%.1fs", sec - scope_view_seconds);
  gfx_measurestr(#tsec, __tw, __th);
  gfx_x = tx - __tw*0.5;
  gfx_y = plot_y + plot_h + floor(4 * scale);
  tx <= plot_x + plot_w ? gfx_drawstr(#tsec);
  sec += 1;
);

  y += panel_h + panel_gap;
);

title_stereo = compact_mode ? "STEREO" : "STEREO ANALYZER";
Panel(x0, y, row_w, panel_h, title_stereo);

gonio_x = x0 + panel_pad;
gonio_y = y + panel_title_h + floor(2 * scale);
gonio_w = row_w - panel_pad*2;
gonio_h2 = panel_h - panel_title_h - panel_pad;
gonio_w < 1 ? gonio_w = 1;
gonio_h2 < 1 ? gonio_h2 = 1;

(gonio_img_w != floor(gonio_w) || gonio_img_h != floor(gonio_h2)) ? (
  gonio_img_w = max(1, floor(gonio_w));
  gonio_img_h = max(1, floor(gonio_h2));
  gfx_setimgdim(gonio_img, gonio_img_w, gonio_img_h);
  gfx_dest = gonio_img;
  SetColor(c_bg_r, c_bg_g, c_bg_b, 1);
  gfx_rect(0, 0, gonio_img_w, gonio_img_h, 1);
);

gfx_dest = gonio_img;
SetColor(c_bg_r, c_bg_g, c_bg_b, 1 - gonio_decay);
gfx_rect(0, 0, gonio_img_w, gonio_img_h, 1);

gcx = gonio_img_w * 0.5;
gcy = gonio_img_h * 0.5;
gscale = min(gonio_img_w, gonio_img_h) * 0.48;

SetColor(1, 1, 1, 0.15);
g_sz = gscale * 0.7; 
gfx_line(gcx - g_sz, gcy + g_sz, gcx + g_sz, gcy - g_sz); 
gfx_line(gcx - g_sz, gcy - g_sz, gcx + g_sz, gcy + g_sz); 

SetColor(0.35, 0.90, 0.55, 0.90);
first_point = 1;
i = 0;
loop(1024, 
  idx = (buf_offset + i) % 1024; 
  s_l = buf_l[idx];
  s_r = buf_r[idx];
  gx = (s_l - s_r) * 0.707;
  gy = (s_l + s_r) * 0.707;
  
  xx = gcx + gx * gscale;
  yy = gcy - gy * gscale;
  
  first_point ? (
    gfx_x = xx; gfx_y = yy; first_point = 0;
  ) : (
    gfx_lineto(xx, yy, 1); 
  );
  i += 1;
);

gfx_dest = -1;
gfx_x = gonio_x;
gfx_y = gonio_y;
gfx_a = 1;
gfx_blit(gonio_img, 1, 0);

SetColor(1, 1, 1, 0.10);
gfx_line(gonio_x + gonio_w/2, gonio_y, gonio_x + gonio_w/2, gonio_y + gonio_h2);
gfx_line(gonio_x, gonio_y + gonio_h2/2, gonio_x + gonio_w, gonio_y + gonio_h2/2);

y += panel_h + panel_gap;

panel_h = panel_h_spec;
// Hide title on small screens (scale < 0.55) to maximize graph area
hide_title_mpc = (compact_mode && scale < 0.55);
title_spec = hide_title_mpc ? "" : (compact_mode ? "SPEC" : "SPECTRUM ANALYZER");
Panel(x0, y, row_w, panel_h, title_spec);

// Toolbar area (height defined in UpdateLayout)
eff_title_h = hide_title_mpc ? floor(2 * scale) : panel_title_h;
tb_y = y + eff_title_h;

// Button "F" (Freeze)
btn_w_s = floor(20 * scale); 
btn_h_s = floor(16 * scale); 
btn_x_s = x0 + row_w - panel_pad - btn_w_s; 
btn_y_s = tb_y + (toolbar_h - btn_h_s)/2;

Button(btn_x_s, btn_y_s, btn_w_s, btn_h_s, "F", spec_freeze) ? (
  spec_freeze = 1 - spec_freeze;
  slider_automate(slider9);
);

// Smoothing Selector
btn_w_sm = compact_mode ? max(24, floor(30 * scale)) : floor(50 * scale);
btn_x_sm = btn_x_s - btn_w_sm - floor(6 * scale);
s11_int = floor(spec_smooth_mode + 0.5);
sm_lbl = s11_int == 0 ? "1/3" : s11_int == 1 ? "1/12" : "1/24";
// In compact mode, shorten
compact_mode ? (
  sm_lbl = s11_int == 0 ? "1/3" : s11_int == 1 ? "12" : "24";
);

Button(btn_x_sm, btn_y_s, btn_w_sm, btn_h_s, sm_lbl, 0) ? (
  spec_smooth_mode = (s11_int + 1) % 3;
  slider_automate(spec_smooth_mode);
);

// Averaging Selector (AVG)
btn_w_avg = compact_mode ? max(24, floor(30 * scale)) : floor(40 * scale);
btn_x_avg = btn_x_sm - btn_w_avg - floor(6 * scale);
s7_int = floor(spec_avg_mode + 0.5);
avg_lbl = s7_int == 0 ? "NORM" : s7_int == 1 ? "SLOW" : "AVG";
compact_mode ? (
  avg_lbl = s7_int == 0 ? "NRM" : s7_int == 1 ? "SLW" : "AVG";
);

Button(btn_x_avg, btn_y_s, btn_w_avg, btn_h_s, avg_lbl, s7_int == 2) ? (
  spec_avg_mode = (s7_int + 1) % 3;
  slider_automate(spec_avg_mode);
);

// M/S Selector
btn_w_ms = compact_mode ? max(24, floor(26 * scale)) : floor(36 * scale);
btn_x_ms = btn_x_avg - btn_w_ms - floor(6 * scale);
ms_lbl = spec_mode_ms == 0 ? "ST" : "M/S";
Button(btn_x_ms, btn_y_s, btn_w_ms, btn_h_s, ms_lbl, spec_mode_ms == 1) ? (
  spec_mode_ms = 1 - spec_mode_ms;
  slider_automate(spec_mode_ms);
);

// Slope Slider (Extended Mode only)
compact_mode == 0 ? (
  slope_lbl_w = 0; 
  slope_slider_w = floor(60 * scale);
  
  sl_bar_w = slope_slider_w;
  sl_bar_h = floor(16 * scale);
  sl_bar_x = x0 + row_w - panel_pad - sl_bar_w;
  sl_bar_y = y + (panel_title_h - sl_bar_h)/2;
  
  // Interaction logic
  mouse_cap == 1 && mouse_x >= sl_bar_x && mouse_x < sl_bar_x + sl_bar_w && mouse_y >= y && mouse_y < y + panel_title_h ? (
     val = (mouse_x - sl_bar_x) / sl_bar_w;
     val = Clamp(val, 0, 1);
     spec_slope_db = val * 6.0;
     slider_automate(spec_slope_db);
  );
  
  mouse_cap == 2 && last_mouse_cap == 0 && mouse_x >= sl_bar_x && mouse_x < sl_bar_x + sl_bar_w && mouse_y >= y && mouse_y < y + panel_title_h ? (
      abs(spec_slope_db - 0.0) < 0.1 ? spec_slope_db = 3.0 :
      abs(spec_slope_db - 3.0) < 0.1 ? spec_slope_db = 4.5 :
      abs(spec_slope_db - 4.5) < 0.1 ? spec_slope_db = 0.0 :
      spec_slope_db = 4.5; 
      slider_automate(spec_slope_db);
  );
  
  SetColor(0.2, 0.2, 0.22, 1);
  gfx_rect(sl_bar_x, sl_bar_y, sl_bar_w, sl_bar_h);
  SetColor(0.3, 0.3, 0.35, 1);
  gfx_rect(sl_bar_x+1, sl_bar_y+1, sl_bar_w-2, sl_bar_h-2);
  
  fill_w = (spec_slope_db / 6.0) * sl_bar_w;
  SetColor(0.15, 0.55, 0.35, 0.9);
  gfx_rect(sl_bar_x+1, sl_bar_y+1, max(0, fill_w-2), sl_bar_h-2);
  
  SetColor(1, 1, 1, 0.9);
  gfx_setfont(1, "Arial", f_sz_title);
  sprintf(#sl_val, "%.1f", spec_slope_db);
  gfx_measurestr(#sl_val, sv_w, sv_h);
  gfx_x = sl_bar_x + sl_bar_w/2 - sv_w/2;
  gfx_y = sl_bar_y + (sl_bar_h - sv_h)/2; 
  gfx_drawstr(#sl_val);
);

  // Dynamic Plot X based on label width
  // Hide Y-axis values on small screens (scale < 0.55) to maximize width
  hide_y_labels = (compact_mode && scale < 0.55);

  gfx_setfont(1, "Arial", f_sz_small);
  gfx_measurestr("-90", tw_db, th_db);
  
  plot_x_offset = hide_y_labels ? floor(2 * scale) : tw_db + floor(8 * scale);
  plot_x = x0 + plot_x_offset;
  
  plot_y = y + eff_title_h + toolbar_h;
  plot_w = row_w - (plot_x - x0) - panel_pad; // Adjust width based on new plot_x
  plot_h = panel_h - eff_title_h - toolbar_h - panel_pad - floor(4 * scale); 
  plot_w < 1 ? plot_w = 1;
  plot_h < 1 ? plot_h = 1;

db_min = -90;
db_max = 0;

f_min = 20; 
f_max = srate * 0.5; 
f_max <= f_min ? f_max = f_min + 1;

lf_min = log(f_min);
lf_max = log(f_max);
lf_den = lf_max - lf_min;
lf_den <= 0 ? lf_den = 1;

SetColor(1, 1, 1, 0.10);
tick_db = db_max;
  
// Dynamic Grid Step: ensure at least 15px between labels
px_per_db = plot_h / (db_max - db_min); 
step_db = 6;
loop(5,
  (step_db * abs(px_per_db)) < (15 * scale) ? step_db += 6;
);

guard = 0;
while(tick_db >= db_min && guard < 100) (
  ty = plot_y + (1 - (tick_db - db_min) / (db_max - db_min)) * plot_h;
  gfx_line(plot_x, ty, plot_x + plot_w, ty);
  
  !hide_y_labels ? (
    SetColor(1, 1, 1, 0.55);
    gfx_setfont(1, "Arial", f_sz_small);
    sprintf(#dbs, "%+.0f", tick_db);
    gfx_measurestr(#dbs, __tw, __th);
    gfx_x = plot_x - __tw - 4; // Align right to plot_x
    gfx_y = ty - __th/2; // Center vertically
    gfx_drawstr(#dbs);
    SetColor(1, 1, 1, 0.10);
  );
  tick_db -= step_db;
  guard += 1;
);

SetColor(1, 1, 1, 0.10);
gfx_setfont(1, "Arial", f_sz_small);
f = 20;
guard = 0;
while(f <= f_max + 0.5 && guard < 200) (
  fx = plot_x + (log(f) - lf_min) / lf_den * plot_w;
  gfx_line(fx, plot_y, fx, plot_y + plot_h);
  (f == 20 || f == 50 || f == 100 || f == 200 || f == 500 || f == 1000 || f == 2000 || f == 5000 || f == 10000 || f == 20000) ? (
    SetColor(1, 1, 1, 0.55);
    f >= 1000 ? sprintf(#fs, "%dk", floor(f/1000)) : sprintf(#fs, "%d", f);
    gfx_x = fx + 2;
    gfx_y = plot_y + plot_h - floor(12 * scale);
    gfx_drawstr(#fs);
    SetColor(1, 1, 1, 0.10);
  );

  f < 100 ? f += 10 :
  f < 1000 ? f += 100 :
  f < 10000 ? f += 1000 :
              f += 10000;
  guard += 1;
);

SetColor(1, 1, 1, 0.05); // Minor grid lines (fainter)
f = 20;
guard = 0;
while(f <= f_max + 0.5 && guard < 400) (
  (f % 10 != 0 && f < 100) || (f % 100 != 0 && f < 1000) || (f % 1000 != 0 && f < 10000) || (f % 10000 != 0) ? (
    fx = plot_x + (log(f) - lf_min) / lf_den * plot_w;
    gfx_line(fx, plot_y, fx, plot_y + plot_h);
  );
  f < 100 ? f += 5 :
  f < 1000 ? f += 50 :
  f < 10000 ? f += 500 :
              f += 5000;
  guard += 1;
);

disp_bins = floor(plot_w);
disp_bins > 600 ? disp_bins = 600;
disp_bins < 160 ? disp_bins = 160;

SetColor(0.20, 0.85, 0.45, spec_mode_ms ? 0.25 : 0.18);
DrawSpectrumGraph(spec_buf, 0.20, 0.85, 0.45, spec_mode_ms ? 0.25 : 0.18, 0, 1, 0);

spec_mode_ms ? (
  // Side Fill (Orange)
  DrawSpectrumGraph(spec_buf_s, 1.0, 0.65, 0.2, 0.25, 0, 1, 0);
);

// Mid Line (Green)
DrawSpectrumGraph(spec_buf, 0.6, 0.95, 0.7, 0.9, 1, 0, 0);

spec_mode_ms ? (
  // Side Line (Blue)
  DrawSpectrumGraph(spec_buf_s, 0.2, 0.8, 0.9, 0.9, 1, 0, 0);
);

// Mid Peak (Grey)
DrawSpectrumGraph(spec_peak, 0.9, 0.9, 0.9, 0.6, 1, 0, 1);

spec_mode_ms ? (
  // Side Peak (Blue-ish)
  DrawSpectrumGraph(spec_peak_s, 0.2, 0.8, 0.9, 0.4, 1, 0, 1);
);

spec_hover = mouse_x >= plot_x && mouse_x < plot_x + plot_w && mouse_y >= plot_y && mouse_y < plot_y + plot_h;
spec_hover ? (
  SetColor(1, 1, 1, 0.16);
  gfx_line(mouse_x, plot_y, mouse_x, plot_y + plot_h);
  gfx_line(plot_x, mouse_y, plot_x + plot_w, mouse_y);

  t = (mouse_x - plot_x) / max(1, plot_w);
  t = Clamp(t, 0, 1);
  lf = lf_min + t * lf_den;
  f = exp(lf);

  k = floor(f * fft_size / srate);
  k = Clamp(k, 0, fft_bins - 1);
  mag = spec_buf[k];
  pk = spec_peak[k];
  db = 20 * log(mag + 0.000000000001) * inv_log10;
  db_pk = 20 * log(pk + 0.000000000001) * inv_log10;
  spec_tilt_db_per_oct != 0 ? (
    tilt = spec_tilt_db_per_oct * ((lf - log_1000) * inv_log2);
    db += tilt;
    db_pk += tilt;
  );

  // Tooltip (Deferred Drawing)
  sprintf(#tooltip_str, "%.0f Hz  %+.1f dB  PK %+.1f", f, db, db_pk);
  draw_tooltip = 1;
);

mouse_click && mouse_x >= plot_x && mouse_x < plot_x + plot_w && mouse_y >= plot_y && mouse_y < plot_y + plot_h ? (
  i = 0;
  loop(fft_bins,
    spec_peak[i] = 0;
    i += 1;
  );
);

y += panel_h + panel_gap;

// MONITOR PANEL
panel_h = panel_h_mon; // Use dedicated monitor height
Panel(x0, y, row_w, panel_h, "MONITOR");
btn_gap = gap;

// Adjust button height for Monitor panel to fit signature
sig_res_h = floor(16 * scale);
avail_h_mon = panel_h - panel_title_h - floor(6 * scale) - sig_res_h;
btn_h = floor((avail_h_mon - gap) * 0.5);
btn_h > floor(32 * scale) ? btn_h = floor(32 * scale);
// Ensure button height is at least 24px (16px for small MPC screens)
min_h = (scale < 0.55) ? 16 : 24;
btn_h < min_h ? btn_h = min_h;

btn_area_y = y + panel_title_h + floor(6 * scale);
btn_w2 = (row_w - btn_gap) / 2;
bx = x0;

// Labels
lbl_norm = compact_mode ? "NRM" : "NORMAL";
lbl_dim  = compact_mode ? "DIM" : "-20 db";
lbl_low  = compact_mode ? "LOW" : "LOW-END FOCUS";
lbl_mid  = compact_mode ? "MID" : "MID / HIGH FOCUS";

Button(bx, btn_area_y, btn_w2, btn_h, lbl_norm, ui_monitor_mode == 0) ? (
  ui_monitor_mode = 0; slider1 = 0; monitor_mode = 0;
  slider_automate(slider1);
);
bx += btn_w2 + btn_gap;
Button(bx, btn_area_y, btn_w2, btn_h, lbl_dim, ui_dim_active) ? (
  ui_dim_active = 1 - ui_dim_active; slider3 = ui_dim_active; dim_active = ui_dim_active;
  slider_automate(slider3);
);

bx = x0;
Button(bx, btn_area_y + btn_h + gap, btn_w2, btn_h, lbl_low, ui_low_end_only) ? (
  ui_low_end_only = 1 - ui_low_end_only;
  ui_low_end_only ? ui_mid_high_focus = 0;
);
bx += btn_w2 + btn_gap;
Button(bx, btn_area_y + btn_h + gap, btn_w2, btn_h, lbl_mid, ui_mid_high_focus) ? (
  ui_mid_high_focus = 1 - ui_mid_high_focus;
  ui_mid_high_focus ? ui_low_end_only = 0;
);

// Tooltip Layer (Always on top)
draw_tooltip ? (
  // Adaptive font size for tooltips (scale < 0.55)
  tt_font_sz = (compact_mode && scale < 0.55) ? 11 : max(13, f_sz_norm + 2);
  gfx_setfont(1, "Arial", tt_font_sz);
  gfx_measurestr(#tooltip_str, tw, th);
  
  // Padding & Box Dimensions
  pad_x = 8;
  pad_y = 6;
  box_w = tw + pad_x*2;
  box_h = th + pad_y*2;
  
  // Initial Position: Top-Right relative to mouse
  tx = mouse_x + 15;
  ty = mouse_y - box_h - 10;
  
  // Horizontal Smart Logic: shift left if overflowing right edge
  (tx + box_w > gfx_w) ? tx = mouse_x - box_w - 15;
  // Fail-safe: Clamp X to screen bounds
  tx = max(0, min(tx, gfx_w - box_w));

  // Vertical Smart Logic: shift below mouse if overflowing top edge
  (ty < 0) ? (
    ty_bot = mouse_y + 20;
    // If bottom position also fails, clamp to screen vertical bounds
    (ty_bot + box_h > gfx_h) ? (
        ty = max(0, min(ty_bot, gfx_h - box_h));
    ) : (
        ty = ty_bot;
    );
  );

  // Final Fail-safe Clamp
  ty = max(0, min(ty, gfx_h - box_h));
  
  // Draw Box
  SetColor(0.1, 0.1, 0.1, 0.95);
  gfx_rect(tx, ty, box_w, box_h);
  
  // Draw Text (Relative to Box)
  SetColor(1, 1, 1, 1);
  gfx_x = tx + pad_x; 
  gfx_y = ty + pad_y;
  gfx_drawstr(#tooltip_str);
);

last_mouse_cap = mouse_cap;
